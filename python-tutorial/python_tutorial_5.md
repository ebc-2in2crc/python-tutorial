# 5. データ構造

## 5.1. リスト型についてもう少し

- `list.append(x)`
  - リストの末尾に要素を一つ追加します
  - `a[len(a):] = [x]` と同様です
- `list.extend(iterable)`
    - イテラブルのすべての要素を対象のリストに追加し、リストを拡張します
    - `a[len(a):] = iterable` と同様
- `list.insert(i, x)`
    - 指定した位置に要素を挿入します
    - 第1引数は、リストのインデクスで、そのインデクスを持つ要素の直前に挿入が行われます
    - 従って、 `a.insert(0, x)` はリストの先頭に挿入を行います
    - また `a.insert(len(a), x)` は `a.append(x)` と等価です
- `list.remove(x)`
    - リスト中で x と等しい値を持つ最初の要素を削除します
    - 該当する要素がなければ `ValueError` が送出されます
- `list.pop([i])`
    - 指定された位置の要素をリストから取り除き、それを返します
    - インデックスが指定されていない場合、`a.pop()` はリスト末尾の要素を取り除いて返します
    - リストが空であるか、インデックスがリストの範囲外の場合は、`IndexError` を送出します
- `list.clear()`
    - リスト中の全ての要素を削除します。`del a[:]` と同様です
- `list.index(x[, start[, end]])`
    - リスト中で x と等しい値を持つ最初の要素の位置をゼロから始まる添字で返します
    - 該当する要素がなければ `ValueError` が送出されます。
    - 任意の引数である `start` と `end` はスライス記法として解釈され、リストの探索範囲を指定できます
    - 返される添字は、`start` 引数からの相対位置ではなく、リスト全体の先頭からの位置になります
- `list.count(x)`
    - リストでの x の出現回数を返します
- `list.sort(*, key=None, reverse=False)`
    - リストの項目を、インプレース演算 (in place、元のデータを演算結果で置き換えるやりかた) でソートします
    - 引数はソート方法のカスタマイズに使えます。 `sorted()` の説明を参照してください
- `list.reverse()`
    - リストの要素を、インプレース演算で逆順にします
- `list.copy()`
    - リストの浅い (shallow) コピーを返します。`a[:]` と同様です。

`insert, remove, sort` などのリストを操作するメソッドは `None` を返す。
これは Python の変更可能なデータ構造全てについての設計上の原則となっている。
また、すべてのデータでソートや比較できるわけではない。例えば、`[None, 'hello', 10]` はソートされない。
なぜなら整数は文字列と比べられないし、`None` は他の型と比べられない。

### 5.1.1. リストをスタックとして使う
### 5.1.2. リストをキューとして使う

- リストをキュー (queue) として使うことも可能だが、リストの先頭に対して insert / pop すると遅い
- キューを実装するならば `collections.deque` を使うとよい

```python
from collections import deque
queue = deque(["Eric", "John", "Michael"])
queue.append("Terry")           # Terry が到着
queue.append("Graham")          # Graham が到着
queue.popleft()                 # 最初に到着した人が去って行った

queue.popleft()                 # 2番目の人も去って行った

print(queue)                    # キューに残っているものは到着順
deque(['Michael', 'Terry', 'Graham'])
```

### 5.1.3. リストの内包表記

- リスト内包表記はリストを生成する簡潔な手段を提供している。
- 主な利用場面は、あるシーケンスや iterable (イテレート可能オブジェクト) のそれぞれの要素に対して操作を行った結果をリストにする
- または、ある条件を満たす要素だけからなる部分シーケンスを作成すること

平方のリストを作るプログラム。
変数 `x` はループが終了した後も残る。

```python
squares = []
for x in range(10):
    squares.append(x**2)

print(squares) # 0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

次のようにすると、副作用なく同様のリストを作成できる。

```python
# 関数型バージョン
squares = list(map(lambda x: x**2, range(10)))
print(squares) # 0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

# リスト内包表記バージョン
squares = [x**2 for x in range(10)]
print(squares) # 0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

`if` で任意の要素のみ処理することもできる。

```python
[x ** 2 for x in range(10)]               # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
[x ** 2 for x in range(10) if x % 2 == 0] # [0, 4, 16, 36, 64]
```

### 5.1.4. ネストしたリストの内包表記

かなりいろんな事ができるが、実際には複雑な流れの式よりも組み込み関数を使う方が良い。

たとえば、`matrix` の行と列を入れ替えるならば `zip` 関数を使った方が良い。

```python
matrix = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12],
]

print([[row[i] for row in matrix] for i in range(4)]) # [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
print(list(zip(*matrix)))                             # [(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]
```

## 5.2. del 文

```python
a = [-1, 1, 66.25, 333, 333, 1234.5]
del a[0]
del a[2:4]
del a[:]

# リスト全体を削除
del a
```

## 5.3. タプルとシーケンス

- タプル (tuple) はシーケンス型
- タプルはコンマで区切られたいくつかの値からなる
- 今までに登場したデータ型やデータ構造としては、文字列、リストもシーケンス型

```python
t = 12345, 54321, 'hello!'
print(t[0]) # 12345 
print(t)    # (12345, 54321, 'hello!')

# タプルは入れ子にできる:
u = t, (1, 2, 3, 4, 5)
print(u) # ((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))

# タプルは不変(イミュータブル):
t[0] = 88888 # TypeError: 'tuple' object does not support item assignment

# しかし、可変(ミュータブル)オブジェクトを含むことができる:
v = ([1, 2, 3], [3, 2, 1])
v[0][1] = 200
print() # ([1, 200, 3], [3, 2, 1])
```

- タプルはリストと似ているが、使用される場面や目的は異なる
- タプルは不変 だが、リストは可変。
- タプルは複数の型の要素からなることもあり、リストはたいてい要素の型は同じ
- タプルは要素をアンパック操作やインデックスでアクセスすることが多いが、リストはイテレートでアクセスすることが多い

0個または1個の要素をもつタプルを作成する方法。

```python
empty = ()
singleton = 'hello',    # <-- 末尾のカンマに注意

len(singleton)

print(singleton) # ('hello',)
```

タプルのパック / アンパック操作について。
複数同時の代入は、実はタプルのパックとシーケンスのアンパックを組み合わせたものに過ぎない。

```python
t = 12345, 54321, 'hello!' # パック
x, y, z = t                # アンパック
```

## 5.4. 集合型

- `set` は集合を扱うためのデータ型
- 集合とは、重複する要素をもたない順序づけられていない要素の集まりです
- `Set` オブジェクトは、和 (union)、積 (intersection)、差 (difference)、対称差 (symmetric difference)といった数学的な演算もサポートしている
- 集合を作成するためには、中括弧または `set()` 関数を使用する
  - 空集合を作成するためには `set(`) を使用しなければならない (`{}` ではなく)

```python
basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
# 重複が削除されていることを確認
print(basket)

# 高速なメンバー判定
print('orange' in basket) # True
print('crabgrass' in basket) # False


# 集合演算
a = set('abracadabra')
b = set('alacazam')

# aのユニークな文字
print(a) # {'a', 'r', 'b', 'c', 'd'}

# aにあってbにない文字
print(a - b) # {'d', 'r', 'b'}

# aまたはbまたは両方に存在する文字
print(a | b) # {'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}

# aとbの両方に存在する文字
print(a & b) # {'a', 'c'}

# aまたはbにあるが、両方にはない文字
a ^ b # {'r', 'd', 'b', 'm', 'z', 'l'}
```

`set` 内包もサポートされている。

```python
a = {x for x in 'abracadabra' if x not in 'abc'}
print(a) # {'r', 'd'}
```

## 5.5. 辞書型 (dictionary)

- 辞書は、他の言語で連想配列と呼ばれたりするものと同じ
- 辞書は キー (key) でインデクス化される
- キーは何らかの変更不能な型になる
  - 文字列、数値は常にキーにできる
  - タプルは、文字列、数値、その他のタプルのみを含む場合はキーにすることができる
  - 直接あるいは間接的に変更可能なオブジェクトを含むタプルはキーにできない
- 辞書の生成方法: `{key: value,[key: value]}` 
- `del` でキー / 値のペアを消せる
- 辞書に `list(d)` を実行すると、辞書で使われている全てのキーからなるリストを取得できる
- あるキーが辞書に含まれているかどうかを調べるには `in` を使う

辞書オブジェクトの生成方法いろいろ。

```python
# dict() コンストラクタはキーと値のペアのタプルを含むリストから辞書を生成する
dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])

# 辞書内包表現を使って、任意のキーと値のペアから辞書を作成する
print({x: x**2 for x in (2, 4, 6)) # {2: 4, 4: 16, 6: 36}

# キーが単純な文字列の場合、キーワード引数を使って定義する方が単純な場合もある
print(ict(sape=4139, guido=4127, jack=4098)) # {'sape': 4139, 'guido': 4127, 'jack': 4098}
```

## 5.6. ループのテクニック

辞書に対してループを行う際、 `items()` メソッドを使うとキーとそれに対応する値を同時に取り出せる。

```python
for k, v in {1: "one", 2: "two", 3: "three"}.items():
  print(f"{k}: {v}")
  
# 1: one
# 2: two
# 3: three
```

シーケンスにわたるループを行う際、 `enumerate()` 関数を使うと、要素のインデックスと要素を同時に取り出すことができる。

```python
for i, v in enumerate(['tic', 'tac', 'toe']):
    print(i, v)

# 0 tic
# 1 tac
# 2 toe
```

その他。

- 二つまたはそれ以上のシーケンス型を同時にループする: `zip()`
- シーケンスを逆方向にループする: `reversed()`
- シーケンスをソートされた順序でループする: `sorted()`
- シーケンスの重複要素を除去する: `set()`
  - `set()` + `sorted()` を使う: 順番が整列されているシーケンスで、同一要素に1度のみループでアクセスする慣用的な方法
- ループ内でリストを変更したいときは、代わりに新しいリストを作ってしまうほうがより簡単で安全なことが多い

## 5.7. 条件についてもう少し

- `in`, `not in`: ある値があるコンテナーの中に存在するかをテストする
- `is`, `is not`: 二つのオブジェクトが実際に同じオブジェクトであるかどうかをテストする
- `and`, `or`: で比較演算を組み合わせる
  - 上記のようなブール演算子は短絡演算。
- 比較は連結できる。例えば `a < b == c` は、 a が b より小さく、かつ b と c が等しいかどうかをテストする


## 5.8. シーケンスとその他の型の比較

